# CI for AuthPackage (Core).

trigger:
  branches:
    include:
      - release
pr:
  branches:
    include:
      - release

pool:
  vmImage: macos-latest

variables:
  CONFIG: debug
  SONAR_ENABLED: 'false'                  # flip to 'true' after you install the SonarQube extension
  SONARQ_ENDPOINT: 'sonarqube-authpackage'
  SONAR_PROJECT_KEY: 'authpackage'
  SONAR_PROJECT_NAME: 'authpackage'

steps:
  - checkout: self
    fetchDepth: 0

  - task: Cache@2
    displayName: Cache SPM (.build/.swiftpm)
    inputs:
      key: 'spm | "$(Agent.OS)" | **/Package.resolved'
      restoreKeys: |
        spm | "$(Agent.OS)"
      path: |
        .build
        .swiftpm

  - script: |
      set -euo pipefail
      swift --version
      xcodebuild -version
    displayName: Show toolchain versions

  - script: |
      set -euo pipefail
      echo "Running SwiftPM tests with coverageâ€¦"
      swift test --enable-code-coverage

      # Determine coverage profile path (newer toolchains)
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        # Fallback for older toolchains
        PROF=".build/debug/codecov/default.profdata"
      fi

      # Determine test runner binary for llvm-cov
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi

      echo "Profile: $PROF"
      echo "Test binary: $TEST_BIN"

      # Produce LCOV now so Sonar is plug-and-play later
      xcrun llvm-cov export -format=lcov -instr-profile "$PROF" "$TEST_BIN" > coverage.lcov
    displayName: Build & Test (SwiftPM) + Generate coverage

  # ---------- SonarQube (completely excluded until SONAR_ENABLED == 'true') ----------
  # Using a compile-time template 'if' so Azure doesn't even try to load the tasks
  - ${{ if eq(variables.SONAR_ENABLED, 'true') }}:
    - task: SonarQubePrepare@6
      displayName: Prepare SonarQube
      inputs:
        SonarQube: '$(SONARQ_ENDPOINT)'
        scannerMode: 'CLI'
        configMode: 'file'                   # uses sonar-project.properties in repo
        cliProjectKey: '$(SONAR_PROJECT_KEY)'
        cliProjectName: '$(SONAR_PROJECT_NAME)'

    - task: SonarQubeAnalyze@6
      displayName: Run SonarQube analysis

    - task: SonarQubePublish@6
      displayName: Publish Sonar Quality Gate
      inputs:
        pollingTimeoutSec: '300'
  # -------------------------------------------------------------------------------

  # Build a release (optional, quick)
  - script: |
      set -euo pipefail
      swift build -c release
    displayName: Build release (optional)
    condition: succeeded()

  # Package source artifact (only if tests passed)
  - script: |
      set -euo pipefail
      rm -rf dist
      mkdir -p dist/pkg

      # Include manifest + sources + docs + (optional) coverage
      cp -a Package.swift dist/pkg/
      [ -f Package.resolved ] && cp Package.resolved dist/pkg/ || true
      [ -d Sources ] && cp -a Sources dist/pkg/ || true
      [ -f README.md ] && cp README.md dist/pkg/ || true
      [ -f LICENSE ] && cp LICENSE dist/pkg/ || true
      [ -f coverage.lcov ] && cp coverage.lcov dist/pkg/ || true

      # Short commit hash for filename
      SHORT="${BUILD_SOURCEVERSION:0:7}"
      pushd dist >/dev/null
      zip -r "authpackage-src-${SHORT}.zip" pkg >/dev/null
      popd >/dev/null

      echo "Created dist/authpackage-src-${SHORT}.zip"
    displayName: Create package source artifact
    condition: succeeded()

  - task: PublishPipelineArtifact@1
    displayName: Publish package artifact
    condition: succeeded()
    inputs:
      targetPath: 'dist'
      artifact: 'authpackage'
