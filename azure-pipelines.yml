# -------------------------------
# AuthPackage – CI (release branch)
# -------------------------------

# Human-friendly run name:
name: authpkg_release_$(Date:yyyyMMdd).$(Rev:r)

trigger:
  branches:
    include:
      - release

pr:
  branches:
    include:
      - release

pool:
  vmImage: macos-latest

variables:
  # Build mode for swift build (we build once more after tests)
  CONFIG: release

  # SonarCloud
  SONAR_ENABLED: 'true'
  SONARQ_ENDPOINT: 'sonarcloud-authpackage'
  SONAR_ORG: "ciscode"
  SONAR_PROJECT_KEY: 'CISCODEAPPS_pkg-ios-auth'
  SONAR_PROJECT_NAME: 'pkg-ios-auth'

  # Azure Artifacts feed (optional)
  FEED_PATH: '$(System.TeamProject)/ios-packages'
  PACKAGE_NAME: 'authpackage'

  # Will be overridden by version resolver
  PACKAGE_VERSION: '0.0.0-rc.0'

steps:
  # Ensure later git commands reuse OAuth token
  - checkout: self
    fetchDepth: 0
    persistCredentials: true
    displayName: "Checkout repository"

  # Authenticated tag fetch (so versioning sees all tags)
  - script: |
      set -euo pipefail
      git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" \
          fetch --tags --force --prune origin
    env:
      System.AccessToken: $(System.AccessToken)
    displayName: "Fetch tags (auth)"

  # Resolve SemVer
  # - If building a tag 'vX.Y.Z' => version 'X.Y.Z'
  # - Else on 'release' branch   => 'NEXT_MINOR.0-rc.YYYYMMDD.BUILDID'
  - script: |
      set -euo pipefail

      REF="${BUILD_SOURCEBRANCH}"

      # Prefer describe; else fall back to highest vX.Y.Z in repo
      get_last_tag() {
        git describe --tags --abbrev=0 --match 'v[0-9]*' 2>/dev/null \
        || git tag -l 'v[0-9]*' --sort=-v:refname | head -n1 \
        || true
      }

      if [[ "$REF" == refs/tags/v* ]]; then
        VER="${REF#refs/tags/v}"
        CHANNEL="stable"
      else
        LAST_TAG="$(get_last_tag)"
        if [[ -z "$LAST_TAG" ]]; then
          MAJ=0; MIN=0; PAT=0
        else
          BASE="${LAST_TAG#v}"
          IFS=. read -r MAJ MIN PAT <<< "$BASE"
        fi
        NEXT="${MAJ}.$((MIN+1)).0"
        DATE="$(date +%Y%m%d)"
        VER="${NEXT}-rc.${DATE}.${BUILD_BUILDID}"
        CHANNEL="rc"
      fi

      echo "Resolved PACKAGE_VERSION=$VER (channel=$CHANNEL)"
      echo "##vso[task.setvariable variable=PACKAGE_VERSION]$VER"
      echo "##vso[task.setvariable variable=RELEASE_CHANNEL]$CHANNEL"
    displayName: "Resolve package version (SemVer + rc)"

  - script: |
      set -euo pipefail
      echo "Swift toolchain:"
      swift --version
      echo "Xcode:"
      xcodebuild -version
    displayName: "Show toolchain versions"

  - script: |
      set -euo pipefail
      echo "Running SwiftPM tests with coverage…"
      swift test --enable-code-coverage

      # Locate coverage profile (newer toolchains)
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        PROF=".build/debug/codecov/default.profdata"
      fi

      # Test runner binary for llvm-cov
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi

      echo "Coverage profile: $PROF"
      echo "Test binary: $TEST_BIN"

      # Produce LCOV (for DevOps UI) + Swift text (for Sonar)
      xcrun llvm-cov export -format=lcov -instr-profile "$PROF" "$TEST_BIN" > coverage.lcov
      echo "Wrote coverage.lcov"
      xcrun llvm-cov show "$TEST_BIN" -instr-profile "$PROF" > coverage.swift.txt
      echo "Wrote coverage.swift.txt for SonarSwift"
    displayName: "Build & test (with coverage)"

  # Convert LCOV to Cobertura XML for Azure DevOps UI
  - script: |
      set -euo pipefail
      python3 -m pip install --user lcov_cobertura
      python3 -m lcov_cobertura coverage.lcov --output coverage.cobertura.xml
      echo "Wrote coverage.cobertura.xml"
    displayName: "Convert coverage: LCOV → Cobertura XML"

  # Publish to the Code Coverage tab
  - task: PublishCodeCoverageResults@2
    displayName: "Publish code coverage (Cobertura)"
    inputs:
      codeCoverageTool: Cobertura
      summaryFileLocation: 'coverage.cobertura.xml'
      reportDirectory: 'coverage-html'
      failIfCoverageEmpty: false

  # Generate HTML coverage (optional)
  - script: |
      set -euo pipefail
      mkdir -p coverage-html
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        PROF=".build/debug/codecov/default.profdata"
      fi
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi
      xcrun llvm-cov show "$TEST_BIN" -instr-profile "$PROF" -format=html -output-dir coverage-html
    displayName: "Generate HTML coverage (optional)"

  # Only publish HTML if the folder exists (Azure conditions don't support exists())
  - script: |
      if [ -d coverage-html ]; then
        echo "##vso[task.setvariable variable=PUBLISH_HTML]true"
        echo "coverage-html exists, will publish."
      else
        echo "coverage-html is missing, skipping publish."
      fi
    displayName: "Check coverage-html existence"

  - task: PublishPipelineArtifact@1
    displayName: "Publish coverage HTML (optional)"
    condition: and(succeededOrFailed(), eq(variables['PUBLISH_HTML'], 'true'))
    inputs:
      targetPath: 'coverage-html'
      artifact: 'coverage-html'

  # ---- SonarCloud (v3 tasks) ----
  - ${{ if eq(variables['SONAR_ENABLED'], 'true') }}:
    - task: SonarCloudPrepare@3
      displayName: "SonarCloud | Prepare analysis"
      inputs:
        SonarCloud: '$(SONARQ_ENDPOINT)'
        organization: '$(SONAR_ORG)'
        scannerMode: 'CLI'
        configMode: 'file'
        cliProjectKey: '$(SONAR_PROJECT_KEY)'
        cliProjectName: '$(SONAR_PROJECT_NAME)'
        extraProperties: |
          sonar.projectVersion=$(Build.BuildNumber)
          sonar.branch.name=$(Build.SourceBranchName)
          sonar.scm.revision=$(Build.SourceVersion)

    - task: SonarCloudAnalyze@3
      displayName: "SonarCloud | Run analysis"

    - task: SonarCloudPublish@3
      displayName: "SonarCloud | Publish Quality Gate"
      condition: succeeded()
      inputs:
        pollingTimeoutSec: '600'
  # -------------------------------

  - script: |
      set -euo pipefail
      echo "Building package in release mode…"
      swift build -c "$(CONFIG)"
    displayName: "Build package (release)"
    condition: succeeded()

  - script: |
      set -euo pipefail
      echo "Packaging source artifact…"
      rm -rf dist && mkdir -p dist/pkg

      cp -a Package.swift dist/pkg/
      [ -f Package.resolved ] && cp Package.resolved dist/pkg/ || true
      [ -d Sources ] && cp -a Sources dist/pkg/ || true
      [ -f README.md ] && cp README.md dist/pkg/ || true
      [ -f LICENSE ] && cp LICENSE dist/pkg/ || true
      [ -f coverage.lcov ] && cp coverage.lcov dist/pkg/ || true

      SHORT="${BUILD_SOURCEVERSION:0:7}"
      BRANCH="${BUILD_SOURCEBRANCHNAME//\//-}"
      pushd dist >/dev/null
      zip -rq "AuthPackage_src_${BRANCH}_v$(PACKAGE_VERSION)_${SHORT}.zip" pkg
      popd >/dev/null

      echo "Created dist/AuthPackage_src_${BRANCH}_v$(PACKAGE_VERSION)_${SHORT}.zip"
    displayName: "Create source artifact (.zip)"
    condition: succeeded()

  - task: PublishPipelineArtifact@1
    displayName: "Publish artifact: AuthPackage (source zip)"
    condition: succeeded()
    inputs:
      targetPath: 'dist'
      artifact: 'AuthPackage'

  # Publish to Azure Artifacts feed (optional)
  - task: UniversalPackages@0
    displayName: "Artifacts feed: publish Universal Package v$(PACKAGE_VERSION)"
    condition: succeeded()
    inputs:
      command: publish
      publishDirectory: 'dist/pkg'
      feedsToUse: internal
      vstsFeedPublish: '$(FEED_PATH)'
      vstsFeedPackagePublish: '$(PACKAGE_NAME)'
      versionOption: custom
      versionPublish: '$(PACKAGE_VERSION)'
      packagePublishDescription: 'AuthPackage source + coverage from $(Build.SourceVersion)'
      
  # ---------------------------------------------
  # GitHub mirror + release (handles empty repos)
  # ---------------------------------------------

  # Preflight: empty repo & default branch alignment
  - script: |
      set -euo pipefail

      # --- Guards ---
      if [[ -z "${GITHUB_TOKEN:-}" || "${GITHUB_TOKEN:-}" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
        echo "ERROR: GITHUB_TOKEN missing. Add a secret pipeline variable."; exit 1
      fi

      # --- Normalize Azure placeholders (e.g., '$(GITHUB_REPO)') ---
      normalize_var() {
        local name="$1"
        local val="${!name:-}"
        if [[ -z "$val" || "$val" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
          eval "unset $name"
        fi
      }
      normalize_var GITHUB_REPO
      normalize_var GITHUB_DEFAULT_BRANCH

      # --- Defaults (only applied if not provided) ---
      : "${GITHUB_REPO:=CISCODE-MA/authpackage_Swift}"      # owner/repo
      : "${GITHUB_DEFAULT_BRANCH:=master}"             # change to 'main' if you prefer

      export GH_TOKEN="$GITHUB_TOKEN"
      export GH_REPO="$GITHUB_REPO"

      echo "Configuring authenticated GitHub remote…"
      git remote remove github 2>/dev/null || true
      git remote add github "https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"

      echo "Checking if remote repo has any branches…"
      if ! HEADS_RAW="$(git ls-remote --heads github 2>/dev/null)"; then
        echo "ERROR: Could not query remote. Check repo '${GITHUB_REPO}' exists and PAT permissions."; exit 1
      fi
      HEADS_COUNT="$(printf "%s" "$HEADS_RAW" | wc -l | tr -d ' ')"
      echo "Remote heads: ${HEADS_COUNT}"

      if [[ "${HEADS_COUNT}" = "0" ]]; then
        echo "Remote appears EMPTY. Pushing initial branch: ${GITHUB_DEFAULT_BRANCH}"
        git push github "HEAD:refs/heads/${GITHUB_DEFAULT_BRANCH}"

        echo "Setting GitHub default branch to ${GITHUB_DEFAULT_BRANCH}…"
        echo "$GH_TOKEN" | gh auth login --with-token
        gh repo edit "${GITHUB_REPO}" --default-branch "${GITHUB_DEFAULT_BRANCH}"
        echo "Default branch set."
      else
        echo "Remote already has branches. Skipping default-branch change."
      fi
    displayName: "GitHub preflight: empty repo & default branch"
    condition: succeeded()
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)                     # secret (required)
      GITHUB_REPO: $(GITHUB_REPO)                       # optional: owner/repo
      GITHUB_DEFAULT_BRANCH: $(GITHUB_DEFAULT_BRANCH)   # optional: main/master

  # Push the built commit and the version tag
  - script: |
      set -euo pipefail

      if [[ -z "${GITHUB_TOKEN:-}" || "${GITHUB_TOKEN:-}" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
        echo "ERROR: GITHUB_TOKEN missing."; exit 1
      fi

      normalize_var() {
        local name="$1"
        local val="${!name:-}"
        if [[ -z "$val" || "$val" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
          eval "unset $name"
        fi
      }
      normalize_var GITHUB_REPO
      normalize_var GITHUB_DEFAULT_BRANCH

      : "${GITHUB_REPO:=CISCODE-MA/authpackage_swift}"
      : "${GITHUB_DEFAULT_BRANCH:=master}"

      git remote remove github 2>/dev/null || true
      git remote add github "https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"

      TAG="v${PACKAGE_VERSION}"
      if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
        echo "Tag ${TAG} already exists locally."
      else
        git tag -a "${TAG}" -m "AuthPackage ${TAG}"
        echo "Created tag ${TAG}"
      fi

      echo "Pushing commit to ${GITHUB_DEFAULT_BRANCH} (ff-only)…"
      git push github "HEAD:refs/heads/${GITHUB_DEFAULT_BRANCH}"
  
      echo "Pushing tag ${TAG}…"
      git push github "refs/tags/${TAG}"
    displayName: "GitHub: push branch + tag"
    condition: succeeded()
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
      GITHUB_REPO: $(GITHUB_REPO)
      GITHUB_DEFAULT_BRANCH: $(GITHUB_DEFAULT_BRANCH)

  # Create (or update) the GitHub Release and upload the packaged asset
  - script: |
      set -euo pipefail

      if [[ -z "${GITHUB_TOKEN:-}" || "${GITHUB_TOKEN:-}" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
        echo "ERROR: GITHUB_TOKEN missing."; exit 1
      fi

      normalize_var() {
        local name="$1"
        local val="${!name:-}"
        if [[ -z "$val" || "$val" =~ ^\$\([A-Za-z0-9_.-]+\)$ ]]; then
          eval "unset $name"
        fi
      }
      normalize_var GITHUB_REPO

      : "${GITHUB_REPO:=CISCODE-MA/authpackage_Swift}"
      export GH_TOKEN="$GITHUB_TOKEN"
      export GH_REPO="$GITHUB_REPO"

      echo "Authenticating gh…"
      echo "$GH_TOKEN" | gh auth login --with-token

      TAG="v${PACKAGE_VERSION}"
      TITLE="AuthPackage ${TAG}"
  
      ASSET="$(ls dist/AuthPackage_src_*_v${PACKAGE_VERSION}_*.zip | head -n1 || true)"
      if [[ -z "$ASSET" ]]; then
        echo "ERROR: could not find release asset ZIP in dist/. Did the packaging step run?"; exit 1
      fi
      echo "Attaching asset: $ASSET"

      if [[ -f CHANGELOG.md ]]; then
        NOTES_OPT=(--notes-file CHANGELOG.md)
      else
        printf "Release %s\n\nBuild: %s\nBranch: %s\nCommit: %s\n" \
          "$TAG" "$(Build.BuildNumber)" "$(Build.SourceBranchName)" "$(Build.SourceVersion)" > /tmp/release-notes.txt
        NOTES_OPT=(--notes-file /tmp/release-notes.txt)
      fi

      if [[ "${RELEASE_CHANNEL:-rc}" == "stable" ]]; then
        echo "Creating/updating STABLE Release ${TAG}…"
        gh release create "$TAG" "$ASSET" --title "$TITLE" "${NOTES_OPT[@]}" --latest --verify-tag || \
        gh release upload  "$TAG" "$ASSET" --clobber
      else
        echo "Creating/updating PRERELEASE ${TAG}…"
        gh release create "$TAG" "$ASSET" --title "$TITLE" "${NOTES_OPT[@]}" --prerelease --verify-tag || \
        gh release upload  "$TAG" "$ASSET" --clobber
      fi
    displayName: "GitHub: create Release + upload asset"
    condition: succeeded()
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
      GITHUB_REPO: $(GITHUB_REPO)
