# Azure DevOps CI for Swift Package (Core).

trigger:
  branches:
    include:
      - release
pr:
  branches:
    include:
      - release

pool:
  vmImage: macos-latest

variables:
  CONFIG: debug
  SONAR_ENABLED: 'false'
  SONARQ_ENDPOINT: 'sonarqube-authpackage'
  SONAR_PROJECT_KEY: 'authpackage'
  SONAR_PROJECT_NAME: 'authpackage'

steps:
  - checkout: self
    fetchDepth: 0

  - task: Cache@2
    displayName: Cache SPM (.build/.swiftpm)
    inputs:
      key: 'spm | "$(Agent.OS)" | **/Package.resolved'
      restoreKeys: |
        spm | "$(Agent.OS)"
      path: |
        .build
        .swiftpm

  - script: |
      set -euo pipefail
      swift --version
      xcodebuild -version
    displayName: Show toolchain versions

  - script: |
      set -euo pipefail
      echo "Running SwiftPM tests with coverageâ€¦"
      swift test --enable-code-coverage

      # Modern way to find coverage/profile
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        PROF=".build/debug/codecov/default.profdata"
      fi

      # Test runner binary for llvm-cov
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi

      echo "Profile: $PROF"
      echo "Test binary: $TEST_BIN"

      # Produce lcov so Sonar is plug-and-play later
      xcrun llvm-cov export -format=lcov -instr-profile "$PROF" "$TEST_BIN" > coverage.lcov
    displayName: Build & Test (SwiftPM) + generate coverage

  # ---- SonarQube (disabled until SONAR_ENABLED == 'true') ----
  - task: SonarQubePrepare@6
    displayName: Prepare SonarQube
    condition: and(succeeded(), eq(variables['SONAR_ENABLED'], 'true'))
    inputs:
      SonarQube: '$(SONARQ_ENDPOINT)'
      scannerMode: 'CLI'
      configMode: 'file'                   
      cliProjectKey: '$(SONAR_PROJECT_KEY)'
      cliProjectName: '$(SONAR_PROJECT_NAME)'

  - task: SonarQubeAnalyze@6
    displayName: Run SonarQube analysis
    condition: and(succeeded(), eq(variables['SONAR_ENABLED'], 'true'))

  - task: SonarQubePublish@6
    displayName: Publish Sonar Quality Gate
    condition: and(succeeded(), eq(variables['SONAR_ENABLED'], 'true'))
    inputs:
      pollingTimeoutSec: '300'
  # ------------------------------------------------------------

  # Build a release (optional, fast; artifact is source-based for portability)
  - script: |
      set -euo pipefail
      swift build -c release
    displayName: Build release (optional)
    condition: succeeded()

  # Package *source* artifact so downstream consumers can pull this exact version
  - script: |
      set -euo pipefail
      rm -rf dist
      mkdir -p dist/pkg

      # include canonical source + manifest + docs
      cp -a Package.swift dist/pkg/
      [ -f Package.resolved ] && cp Package.resolved dist/pkg/ || true
      [ -d Sources ] && cp -a Sources dist/pkg/ || true
      [ -f README.md ] && cp README.md dist/pkg/ || true
      [ -f LICENSE ] && cp LICENSE dist/pkg/ || true

      # keep coverage for future code-quality stages (optional)
      [ -f coverage.lcov ] && cp coverage.lcov dist/pkg/ || true

      pushd dist >/dev/null
      zip -r "authpackage-src-$(Build.SourceVersionShortHash).zip" pkg >/dev/null
      popd >/dev/null

      echo "Created dist/authpackage-src-$(Build.SourceVersionShortHash).zip"
    displayName: Create package source artifact
    condition: succeeded()

  - task: PublishPipelineArtifact@1
    displayName: Publish package artifact
    condition: succeeded()
    inputs:
      targetPath: 'dist'
      artifact: 'authpackage'
