# -------------------------------
# AuthPackage – CI (release branch)
# -------------------------------

# Human-friendly run name
name: authpkg_release_$(Date:yyyyMMdd).$(Rev:r)

trigger:
  branches:
    include:
      - release
  # (Optional) build on version tags too (for stable releases)
  tags:
    include:
      - v*

pr:
  branches:
    include:
      - release

pool:
  vmImage: macos-latest

variables:
  # Build mode for swift build (we build once more after tests)
  CONFIG: release

  # Sonar toggle (leave 'false' until the extension + service connection exist)
  SONAR_ENABLED: 'false'
  SONARQ_ENDPOINT: 'sonarqube-authpackage'
  SONAR_PROJECT_KEY: 'authpackage'
  SONAR_PROJECT_NAME: 'AuthPackage'

  # Azure Artifacts feed (Universal Package)
  FEED_NAME: 'ios-packages'   
  PACKAGE_NAME: 'authpackage'

  # Default; will be overridden by "Resolve package version" step
  PACKAGE_VERSION: '1.0.0-$(Date:yyyyMMdd).$(Rev:r)'

steps:
  - checkout: self
    fetchDepth: 0
    displayName: "Checkout repository"

  # Resolve PACKAGE_VERSION:
  # - If building a tag 'vX.Y.Z' => version 'X.Y.Z'
  # - Else on branch 'release'   => 'NEXT_MINOR.0-rc.YYYYMMDD.BUILDID'
  - script: |
      set -euo pipefail
      REF="$(Build.SourceBranch)"

      if [[ "$REF" == refs/tags/v* ]]; then
        VER="${REF#refs/tags/v}"
        CHANNEL="stable"
      else
        LAST_TAG=$(git describe --tags --abbrev=0 --match 'v[0-9]*' 2>/dev/null || echo 'v0.0.0')
        BASE="${LAST_TAG#v}"
        IFS=. read -r MAJ MIN PAT <<< "$BASE"
        NEXT="${MAJ}.$((MIN+1)).0"
        DATE=$(date +%Y%m%d)
        VER="${NEXT}-rc.${DATE}.${BUILD_BUILDID}"
        CHANNEL="rc"
      fi

      echo "##vso[task.setvariable variable=PACKAGE_VERSION]$VER"
      echo "##vso[task.setvariable variable=RELEASE_CHANNEL]$CHANNEL"
      echo "Resolved PACKAGE_VERSION=$VER (channel=$CHANNEL)"
    displayName: "Resolve package version (SemVer + rc)"

  - script: |
      set -euo pipefail
      echo "Swift toolchain:"
      swift --version
      echo "Xcode:"
      xcodebuild -version
    displayName: "Show toolchain versions"

  - script: |
      set -euo pipefail
      echo "Running SwiftPM tests with coverage…"
      swift test --enable-code-coverage

      # Locate coverage profile (newer toolchains)
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        # Fallback path used by SwiftPM
        PROF=".build/debug/codecov/default.profdata"
      fi

      # Test runner binary for llvm-cov
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi

      echo "Coverage profile: $PROF"
      echo "Test binary: $TEST_BIN"

      # Produce LCOV so Sonar can ingest later
      xcrun llvm-cov export -format=lcov -instr-profile "$PROF" "$TEST_BIN" > coverage.lcov
      echo "Wrote coverage.lcov"
    displayName: "Build & test (with coverage)"

  # ---- SonarQube (compile-time excluded until SONAR_ENABLED == 'true') ----
  - ${{ if eq(variables.SONAR_ENABLED, 'true') }}:
    - task: SonarQubePrepare@6
      displayName: "SonarQube | Prepare analysis"
      inputs:
        SonarQube: '$(SONARQ_ENDPOINT)'
        scannerMode: 'CLI'
        configMode: 'file'   # uses sonar-project.properties in repo
        cliProjectKey: '$(SONAR_PROJECT_KEY)'
        cliProjectName: '$(SONAR_PROJECT_NAME)'

    - task: SonarQubeAnalyze@6
      displayName: "SonarQube | Run analysis"

    - task: SonarQubePublish@6
      displayName: "SonarQube | Publish Quality Gate"
      inputs:
        pollingTimeoutSec: '300'
  # ------------------------------------------------------------------------

  - script: |
      set -euo pipefail
      echo "Building package in release mode…"
      swift build -c "$(CONFIG)"
    displayName: "Build package (release)"
    condition: succeeded()   # only if tests passed

  - script: |
      set -euo pipefail
      echo "Packaging source artifact…"
      rm -rf dist && mkdir -p dist/pkg

      cp -a Package.swift dist/pkg/
      [ -f Package.resolved ] && cp Package.resolved dist/pkg/ || true
      [ -d Sources ] && cp -a Sources dist/pkg/ || true
      [ -f README.md ] && cp README.md dist/pkg/ || true
      [ -f LICENSE ] && cp LICENSE dist/pkg/ || true
      [ -f coverage.lcov ] && cp coverage.lcov dist/pkg/ || true

      SHORT="${BUILD_SOURCEVERSION:0:7}"
      BRANCH="${BUILD_SOURCEBRANCHNAME//\//-}"
      pushd dist >/dev/null
      zip -rq "AuthPackage_src_${BRANCH}_v$(PACKAGE_VERSION)_${SHORT}.zip" pkg
      popd >/dev/null

      echo "Created dist/AuthPackage_src_${BRANCH}_v$(PACKAGE_VERSION)_${SHORT}.zip"
    displayName: "Create source artifact (.zip)"
    condition: succeeded()

  - task: PublishPipelineArtifact@1
    displayName: "Publish run artifact: AuthPackage (source zip)"
    condition: succeeded()
    inputs:
      targetPath: 'dist'
      artifact: 'AuthPackage'

  - task: UniversalPackages@0
    displayName: "Artifacts feed: publish Universal Package v$(PACKAGE_VERSION)"
    condition: succeeded()   # publish only if tests passed
    inputs:
      command: publish
      publishDirectory: 'dist/pkg'
      feedsToUse: internal
      vstsFeedPublish: '$(FEED_NAME)'
      vstsFeedPackagePublish: '$(PACKAGE_NAME)'
      versionOption: custom
      versionPublish: '$(PACKAGE_VERSION)'
      packagePublishDescription: 'AuthPackage source + coverage from $(Build.SourceVersion)'
