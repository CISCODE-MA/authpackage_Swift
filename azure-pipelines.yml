# -------------------------------
# AuthPackage – CI (release branch)
# -------------------------------

# Human-friendly run name: (used as sonar.projectVersion)
name: authpkg_release_$(Date:yyyyMMdd).$(Rev:r)

trigger:
  branches:
    include: [ release ]

pr:
  branches:
    include: [ release ]

pool:
  vmImage: macos-latest

variables:
- group: AuthPackage-Secrets

  CONFIG: release

  SONAR_ENABLED: 'true'
  SONARQ_ENDPOINT: 'sonarcloud-authpackage'
  SONAR_ORG: "ciscode"
  SONAR_PROJECT_KEY: 'CISCODEAPPS_pkg-ios-auth'
  SONAR_PROJECT_NAME: 'pkg-ios-auth'

  FEED_PATH: '$(System.TeamProject)/ios-packages'
  PACKAGE_NAME: 'authpackage'

  PACKAGE_VERSION: '0.0.0-rc.0'

  GIT_USER_NAME: 'ci-bot'
  GIT_USER_EMAIL: 'ci-bot@ciscod.com'

steps:
  - checkout: self
    fetchDepth: 0
    persistCredentials: true
    displayName: "Checkout repository"

  - script: |
      set -euo pipefail
      git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)"           fetch --tags --force --prune origin
    env:
      System.AccessToken: $(System.AccessToken)
    displayName: "Fetch tags (auth)"

  - script: |
      set -euo pipefail
      REF="${BUILD_SOURCEBRANCH}"
      get_last_tag() {
        git describe --tags --abbrev=0 --match 'v[0-9]*' 2>/dev/null         || git tag -l 'v[0-9]*' --sort=-v:refname | head -n1         || true
      }
      if [[ "$REF" == refs/tags/v* ]]; then
        VER="${REF#refs/tags/v}"
        CHANNEL="stable"
      else
        LAST_TAG="$(get_last_tag)"
        if [[ -z "$LAST_TAG" ]]; then
          MAJ=0; MIN=0; PAT=0
        else
          BASE="${LAST_TAG#v}"
          IFS=. read -r MAJ MIN PAT <<< "$BASE"
        fi
        NEXT="${MAJ}.$((MIN+1)).0"
        DATE="$(date +%Y%m%d)"
        VER="${NEXT}-rc.${DATE}.${BUILD_BUILDID}"
        CHANNEL="rc"
      fi
      echo "Resolved PACKAGE_VERSION=$VER (channel=$CHANNEL)"
      echo "##vso[task.setvariable variable=PACKAGE_VERSION]$VER"
      echo "##vso[task.setvariable variable=RELEASE_CHANNEL]$CHANNEL"
    displayName: "Resolve package version (SemVer + rc)"

  - script: |
      set -euo pipefail
      swift test --enable-code-coverage
      if swift test --show-codecov-path >/dev/null 2>&1; then
        CODECOV_JSON_PATH=$(swift test --show-codecov-path | tail -n1)
        PROF_DIR=$(dirname "$CODECOV_JSON_PATH")
        PROF="$PROF_DIR/default.profdata"
      else
        PROF=".build/debug/codecov/default.profdata"
      fi
      if swift test --show-test-binary-path >/dev/null 2>&1; then
        TEST_BIN=$(swift test --show-test-binary-path)
      else
        TEST_BIN=$(find .build -type f -name '*Tests' -perm -111 2>/dev/null | head -n1)
      fi
      xcrun llvm-cov export -format=lcov -instr-profile "$PROF" "$TEST_BIN" > coverage.lcov
      xcrun llvm-cov show "$TEST_BIN" -instr-profile "$PROF" > coverage.swift.txt
    displayName: "Build & test (with coverage)"

  - script: |
      set -euo pipefail
      python3 -m pip install --user lcov_cobertura
      python3 -m lcov_cobertura coverage.lcov --output coverage.cobertura.xml
    displayName: "Convert coverage: LCOV → Cobertura XML"

  - task: PublishCodeCoverageResults@2
    displayName: "Publish code coverage (Cobertura)"
    inputs:
      codeCoverageTool: Cobertura
      summaryFileLocation: 'coverage.cobertura.xml'
      reportDirectory: 'coverage-html'
      failIfCoverageEmpty: false

  - ${{ if eq(variables['SONAR_ENABLED'], 'true') }}:
    - task: SonarCloudPrepare@3
      inputs:
        SonarCloud: '$(SONARQ_ENDPOINT)'
        organization: '$(SONAR_ORG)'
        scannerMode: 'CLI'
        configMode: 'file'
        cliProjectKey: '$(SONAR_PROJECT_KEY)'
        cliProjectName: '$(SONAR_PROJECT_NAME)'
        extraProperties: |
          sonar.projectVersion=$(Build.BuildNumber)
          sonar.branch.name=$(Build.SourceBranchName)
          sonar.scm.revision=$(Build.SourceVersion)
    - task: SonarCloudAnalyze@3
    - task: SonarCloudPublish@3
      condition: succeeded()
      inputs:
        pollingTimeoutSec: '600'

  - script: |
      set -euo pipefail
      git config user.name  "$(GIT_USER_NAME)"
      git config user.email "$(GIT_USER_EMAIL)"
      last_tag="$(git tag -l 'v[0-9]*' --sort=-v:refname | head -n1 || true)"
      if [[ -z "${last_tag}" ]]; then last_tag="v0.0.0"; fi
      IFS=. read -r LMAJ LMIN LPAT <<< "${last_tag#v}"
      base="${PACKAGE_VERSION%%-*}"
      IFS=. read -r MAJ MIN _ <<< "${base:-0.0.0}"
      if (( MAJ > LMAJ )) || (( MAJ == LMAJ && MIN > LMIN )); then
        NEW_TAG="v${MAJ}.${MIN}.0"
      else
        NEW_TAG="v${LMAJ}.${LMIN}.$((LPAT+1))"
      fi
      echo "Resolved release tag: ${NEW_TAG}"
      echo "##vso[task.setvariable variable=RELEASE_TAG]${NEW_TAG}"
      if git rev-parse -q --verify "refs/tags/${NEW_TAG}" >/dev/null; then
        echo "Tag ${NEW_TAG} already exists"
      else
        git tag -a "${NEW_TAG}" -m "AuthPackage ${NEW_TAG}"
      fi
      git push origin "${NEW_TAG}"
    displayName: "Release tagging (push vX.Y.Z)"
    condition: succeeded()

  - task: UniversalPackages@0
    inputs:
      command: publish
      publishDirectory: 'dist/pkg'
      feedsToUse: internal
      vstsFeedPublish: '$(FEED_PATH)'
      vstsFeedPackagePublish: '$(PACKAGE_NAME)'
      versionOption: custom
      versionPublish: '$(PACKAGE_VERSION)'
      packagePublishDescription: 'AuthPackage source + coverage from $(Build.SourceVersion)'
    condition: succeeded()

  - script: |
      set -euo pipefail
      : "${RELEASE_TAG:?RELEASE_TAG is required}"
      : "${GITHUB_REPO:?GITHUB_REPO is required}"
      INCLUDE=( Package.swift Sources Tests README.md LICENSE )
      WORK=public-export
      rm -rf "$WORK"
      mkdir -p "$WORK"
      for p in "${INCLUDE[@]}"; do
        if [[ -e "$p" ]]; then cp -a "$p" "$WORK"/; fi
      done
      pushd "$WORK" >/dev/null
      git init
      git config user.name  "$(GIT_USER_NAME)"
      git config user.email "$(GIT_USER_EMAIL)"
      git add .
      git commit -m "Release ${RELEASE_TAG}"
      git tag -a "${RELEASE_TAG}" -m "Release ${RELEASE_TAG}"
      GH_URL="https://$(GITHUB_TOKEN)@github.com/$(GITHUB_REPO).git"
      git remote add github "${GH_URL}"
      git branch -M "public/${RELEASE_TAG}"
      git push github "public/${RELEASE_TAG}"
      git push github "${RELEASE_TAG}"
      popd >/dev/null
    displayName: "Publish cleaned release to GitHub"
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
      GITHUB_REPO:  $(GITHUB_REPO)
      GIT_USER_NAME:  $(GIT_USER_NAME)
      GIT_USER_EMAIL: $(GIT_USER_EMAIL)
    condition: succeeded()
